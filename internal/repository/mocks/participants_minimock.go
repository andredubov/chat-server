// Code generated by http://github.com/gojuno/minimock (v3.3.14). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/andredubov/chat-server/internal/repository.Participants -o participants_minimock.go -n ParticipantsMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/andredubov/chat-server/internal/service/model"
	"github.com/gojuno/minimock/v3"
)

// ParticipantsMock implements repository.Participants
type ParticipantsMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreate          func(ctx context.Context, participant model.Participant) (i1 int64, err error)
	inspectFuncCreate   func(ctx context.Context, participant model.Participant)
	afterCreateCounter  uint64
	beforeCreateCounter uint64
	CreateMock          mParticipantsMockCreate

	funcDelete          func(ctx context.Context, participantID int64) (i1 int64, err error)
	inspectFuncDelete   func(ctx context.Context, participantID int64)
	afterDeleteCounter  uint64
	beforeDeleteCounter uint64
	DeleteMock          mParticipantsMockDelete
}

// NewParticipantsMock returns a mock for repository.Participants
func NewParticipantsMock(t minimock.Tester) *ParticipantsMock {
	m := &ParticipantsMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateMock = mParticipantsMockCreate{mock: m}
	m.CreateMock.callArgs = []*ParticipantsMockCreateParams{}

	m.DeleteMock = mParticipantsMockDelete{mock: m}
	m.DeleteMock.callArgs = []*ParticipantsMockDeleteParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mParticipantsMockCreate struct {
	optional           bool
	mock               *ParticipantsMock
	defaultExpectation *ParticipantsMockCreateExpectation
	expectations       []*ParticipantsMockCreateExpectation

	callArgs []*ParticipantsMockCreateParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ParticipantsMockCreateExpectation specifies expectation struct of the Participants.Create
type ParticipantsMockCreateExpectation struct {
	mock      *ParticipantsMock
	params    *ParticipantsMockCreateParams
	paramPtrs *ParticipantsMockCreateParamPtrs
	results   *ParticipantsMockCreateResults
	Counter   uint64
}

// ParticipantsMockCreateParams contains parameters of the Participants.Create
type ParticipantsMockCreateParams struct {
	ctx         context.Context
	participant model.Participant
}

// ParticipantsMockCreateParamPtrs contains pointers to parameters of the Participants.Create
type ParticipantsMockCreateParamPtrs struct {
	ctx         *context.Context
	participant *model.Participant
}

// ParticipantsMockCreateResults contains results of the Participants.Create
type ParticipantsMockCreateResults struct {
	i1  int64
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreate *mParticipantsMockCreate) Optional() *mParticipantsMockCreate {
	mmCreate.optional = true
	return mmCreate
}

// Expect sets up expected params for Participants.Create
func (mmCreate *mParticipantsMockCreate) Expect(ctx context.Context, participant model.Participant) *mParticipantsMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("ParticipantsMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &ParticipantsMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.paramPtrs != nil {
		mmCreate.mock.t.Fatalf("ParticipantsMock.Create mock is already set by ExpectParams functions")
	}

	mmCreate.defaultExpectation.params = &ParticipantsMockCreateParams{ctx, participant}
	for _, e := range mmCreate.expectations {
		if minimock.Equal(e.params, mmCreate.defaultExpectation.params) {
			mmCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreate.defaultExpectation.params)
		}
	}

	return mmCreate
}

// ExpectCtxParam1 sets up expected param ctx for Participants.Create
func (mmCreate *mParticipantsMockCreate) ExpectCtxParam1(ctx context.Context) *mParticipantsMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("ParticipantsMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &ParticipantsMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("ParticipantsMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &ParticipantsMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.ctx = &ctx

	return mmCreate
}

// ExpectParticipantParam2 sets up expected param participant for Participants.Create
func (mmCreate *mParticipantsMockCreate) ExpectParticipantParam2(participant model.Participant) *mParticipantsMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("ParticipantsMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &ParticipantsMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("ParticipantsMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &ParticipantsMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.participant = &participant

	return mmCreate
}

// Inspect accepts an inspector function that has same arguments as the Participants.Create
func (mmCreate *mParticipantsMockCreate) Inspect(f func(ctx context.Context, participant model.Participant)) *mParticipantsMockCreate {
	if mmCreate.mock.inspectFuncCreate != nil {
		mmCreate.mock.t.Fatalf("Inspect function is already set for ParticipantsMock.Create")
	}

	mmCreate.mock.inspectFuncCreate = f

	return mmCreate
}

// Return sets up results that will be returned by Participants.Create
func (mmCreate *mParticipantsMockCreate) Return(i1 int64, err error) *ParticipantsMock {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("ParticipantsMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &ParticipantsMockCreateExpectation{mock: mmCreate.mock}
	}
	mmCreate.defaultExpectation.results = &ParticipantsMockCreateResults{i1, err}
	return mmCreate.mock
}

// Set uses given function f to mock the Participants.Create method
func (mmCreate *mParticipantsMockCreate) Set(f func(ctx context.Context, participant model.Participant) (i1 int64, err error)) *ParticipantsMock {
	if mmCreate.defaultExpectation != nil {
		mmCreate.mock.t.Fatalf("Default expectation is already set for the Participants.Create method")
	}

	if len(mmCreate.expectations) > 0 {
		mmCreate.mock.t.Fatalf("Some expectations are already set for the Participants.Create method")
	}

	mmCreate.mock.funcCreate = f
	return mmCreate.mock
}

// When sets expectation for the Participants.Create which will trigger the result defined by the following
// Then helper
func (mmCreate *mParticipantsMockCreate) When(ctx context.Context, participant model.Participant) *ParticipantsMockCreateExpectation {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("ParticipantsMock.Create mock is already set by Set")
	}

	expectation := &ParticipantsMockCreateExpectation{
		mock:   mmCreate.mock,
		params: &ParticipantsMockCreateParams{ctx, participant},
	}
	mmCreate.expectations = append(mmCreate.expectations, expectation)
	return expectation
}

// Then sets up Participants.Create return parameters for the expectation previously defined by the When method
func (e *ParticipantsMockCreateExpectation) Then(i1 int64, err error) *ParticipantsMock {
	e.results = &ParticipantsMockCreateResults{i1, err}
	return e.mock
}

// Times sets number of times Participants.Create should be invoked
func (mmCreate *mParticipantsMockCreate) Times(n uint64) *mParticipantsMockCreate {
	if n == 0 {
		mmCreate.mock.t.Fatalf("Times of ParticipantsMock.Create mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreate.expectedInvocations, n)
	return mmCreate
}

func (mmCreate *mParticipantsMockCreate) invocationsDone() bool {
	if len(mmCreate.expectations) == 0 && mmCreate.defaultExpectation == nil && mmCreate.mock.funcCreate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreate.mock.afterCreateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Create implements repository.Participants
func (mmCreate *ParticipantsMock) Create(ctx context.Context, participant model.Participant) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmCreate.beforeCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmCreate.afterCreateCounter, 1)

	if mmCreate.inspectFuncCreate != nil {
		mmCreate.inspectFuncCreate(ctx, participant)
	}

	mm_params := ParticipantsMockCreateParams{ctx, participant}

	// Record call args
	mmCreate.CreateMock.mutex.Lock()
	mmCreate.CreateMock.callArgs = append(mmCreate.CreateMock.callArgs, &mm_params)
	mmCreate.CreateMock.mutex.Unlock()

	for _, e := range mmCreate.CreateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCreate.CreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreate.CreateMock.defaultExpectation.Counter, 1)
		mm_want := mmCreate.CreateMock.defaultExpectation.params
		mm_want_ptrs := mmCreate.CreateMock.defaultExpectation.paramPtrs

		mm_got := ParticipantsMockCreateParams{ctx, participant}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreate.t.Errorf("ParticipantsMock.Create got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.participant != nil && !minimock.Equal(*mm_want_ptrs.participant, mm_got.participant) {
				mmCreate.t.Errorf("ParticipantsMock.Create got unexpected parameter participant, want: %#v, got: %#v%s\n", *mm_want_ptrs.participant, mm_got.participant, minimock.Diff(*mm_want_ptrs.participant, mm_got.participant))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreate.t.Errorf("ParticipantsMock.Create got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreate.CreateMock.defaultExpectation.results
		if mm_results == nil {
			mmCreate.t.Fatal("No results are set for the ParticipantsMock.Create")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCreate.funcCreate != nil {
		return mmCreate.funcCreate(ctx, participant)
	}
	mmCreate.t.Fatalf("Unexpected call to ParticipantsMock.Create. %v %v", ctx, participant)
	return
}

// CreateAfterCounter returns a count of finished ParticipantsMock.Create invocations
func (mmCreate *ParticipantsMock) CreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.afterCreateCounter)
}

// CreateBeforeCounter returns a count of ParticipantsMock.Create invocations
func (mmCreate *ParticipantsMock) CreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.beforeCreateCounter)
}

// Calls returns a list of arguments used in each call to ParticipantsMock.Create.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreate *mParticipantsMockCreate) Calls() []*ParticipantsMockCreateParams {
	mmCreate.mutex.RLock()

	argCopy := make([]*ParticipantsMockCreateParams, len(mmCreate.callArgs))
	copy(argCopy, mmCreate.callArgs)

	mmCreate.mutex.RUnlock()

	return argCopy
}

// MinimockCreateDone returns true if the count of the Create invocations corresponds
// the number of defined expectations
func (m *ParticipantsMock) MinimockCreateDone() bool {
	if m.CreateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateMock.invocationsDone()
}

// MinimockCreateInspect logs each unmet expectation
func (m *ParticipantsMock) MinimockCreateInspect() {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ParticipantsMock.Create with params: %#v", *e.params)
		}
	}

	afterCreateCounter := mm_atomic.LoadUint64(&m.afterCreateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && afterCreateCounter < 1 {
		if m.CreateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ParticipantsMock.Create")
		} else {
			m.t.Errorf("Expected call to ParticipantsMock.Create with params: %#v", *m.CreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && afterCreateCounter < 1 {
		m.t.Error("Expected call to ParticipantsMock.Create")
	}

	if !m.CreateMock.invocationsDone() && afterCreateCounter > 0 {
		m.t.Errorf("Expected %d calls to ParticipantsMock.Create but found %d calls",
			mm_atomic.LoadUint64(&m.CreateMock.expectedInvocations), afterCreateCounter)
	}
}

type mParticipantsMockDelete struct {
	optional           bool
	mock               *ParticipantsMock
	defaultExpectation *ParticipantsMockDeleteExpectation
	expectations       []*ParticipantsMockDeleteExpectation

	callArgs []*ParticipantsMockDeleteParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ParticipantsMockDeleteExpectation specifies expectation struct of the Participants.Delete
type ParticipantsMockDeleteExpectation struct {
	mock      *ParticipantsMock
	params    *ParticipantsMockDeleteParams
	paramPtrs *ParticipantsMockDeleteParamPtrs
	results   *ParticipantsMockDeleteResults
	Counter   uint64
}

// ParticipantsMockDeleteParams contains parameters of the Participants.Delete
type ParticipantsMockDeleteParams struct {
	ctx           context.Context
	participantID int64
}

// ParticipantsMockDeleteParamPtrs contains pointers to parameters of the Participants.Delete
type ParticipantsMockDeleteParamPtrs struct {
	ctx           *context.Context
	participantID *int64
}

// ParticipantsMockDeleteResults contains results of the Participants.Delete
type ParticipantsMockDeleteResults struct {
	i1  int64
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDelete *mParticipantsMockDelete) Optional() *mParticipantsMockDelete {
	mmDelete.optional = true
	return mmDelete
}

// Expect sets up expected params for Participants.Delete
func (mmDelete *mParticipantsMockDelete) Expect(ctx context.Context, participantID int64) *mParticipantsMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("ParticipantsMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &ParticipantsMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.paramPtrs != nil {
		mmDelete.mock.t.Fatalf("ParticipantsMock.Delete mock is already set by ExpectParams functions")
	}

	mmDelete.defaultExpectation.params = &ParticipantsMockDeleteParams{ctx, participantID}
	for _, e := range mmDelete.expectations {
		if minimock.Equal(e.params, mmDelete.defaultExpectation.params) {
			mmDelete.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDelete.defaultExpectation.params)
		}
	}

	return mmDelete
}

// ExpectCtxParam1 sets up expected param ctx for Participants.Delete
func (mmDelete *mParticipantsMockDelete) ExpectCtxParam1(ctx context.Context) *mParticipantsMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("ParticipantsMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &ParticipantsMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.params != nil {
		mmDelete.mock.t.Fatalf("ParticipantsMock.Delete mock is already set by Expect")
	}

	if mmDelete.defaultExpectation.paramPtrs == nil {
		mmDelete.defaultExpectation.paramPtrs = &ParticipantsMockDeleteParamPtrs{}
	}
	mmDelete.defaultExpectation.paramPtrs.ctx = &ctx

	return mmDelete
}

// ExpectParticipantIDParam2 sets up expected param participantID for Participants.Delete
func (mmDelete *mParticipantsMockDelete) ExpectParticipantIDParam2(participantID int64) *mParticipantsMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("ParticipantsMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &ParticipantsMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.params != nil {
		mmDelete.mock.t.Fatalf("ParticipantsMock.Delete mock is already set by Expect")
	}

	if mmDelete.defaultExpectation.paramPtrs == nil {
		mmDelete.defaultExpectation.paramPtrs = &ParticipantsMockDeleteParamPtrs{}
	}
	mmDelete.defaultExpectation.paramPtrs.participantID = &participantID

	return mmDelete
}

// Inspect accepts an inspector function that has same arguments as the Participants.Delete
func (mmDelete *mParticipantsMockDelete) Inspect(f func(ctx context.Context, participantID int64)) *mParticipantsMockDelete {
	if mmDelete.mock.inspectFuncDelete != nil {
		mmDelete.mock.t.Fatalf("Inspect function is already set for ParticipantsMock.Delete")
	}

	mmDelete.mock.inspectFuncDelete = f

	return mmDelete
}

// Return sets up results that will be returned by Participants.Delete
func (mmDelete *mParticipantsMockDelete) Return(i1 int64, err error) *ParticipantsMock {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("ParticipantsMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &ParticipantsMockDeleteExpectation{mock: mmDelete.mock}
	}
	mmDelete.defaultExpectation.results = &ParticipantsMockDeleteResults{i1, err}
	return mmDelete.mock
}

// Set uses given function f to mock the Participants.Delete method
func (mmDelete *mParticipantsMockDelete) Set(f func(ctx context.Context, participantID int64) (i1 int64, err error)) *ParticipantsMock {
	if mmDelete.defaultExpectation != nil {
		mmDelete.mock.t.Fatalf("Default expectation is already set for the Participants.Delete method")
	}

	if len(mmDelete.expectations) > 0 {
		mmDelete.mock.t.Fatalf("Some expectations are already set for the Participants.Delete method")
	}

	mmDelete.mock.funcDelete = f
	return mmDelete.mock
}

// When sets expectation for the Participants.Delete which will trigger the result defined by the following
// Then helper
func (mmDelete *mParticipantsMockDelete) When(ctx context.Context, participantID int64) *ParticipantsMockDeleteExpectation {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("ParticipantsMock.Delete mock is already set by Set")
	}

	expectation := &ParticipantsMockDeleteExpectation{
		mock:   mmDelete.mock,
		params: &ParticipantsMockDeleteParams{ctx, participantID},
	}
	mmDelete.expectations = append(mmDelete.expectations, expectation)
	return expectation
}

// Then sets up Participants.Delete return parameters for the expectation previously defined by the When method
func (e *ParticipantsMockDeleteExpectation) Then(i1 int64, err error) *ParticipantsMock {
	e.results = &ParticipantsMockDeleteResults{i1, err}
	return e.mock
}

// Times sets number of times Participants.Delete should be invoked
func (mmDelete *mParticipantsMockDelete) Times(n uint64) *mParticipantsMockDelete {
	if n == 0 {
		mmDelete.mock.t.Fatalf("Times of ParticipantsMock.Delete mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDelete.expectedInvocations, n)
	return mmDelete
}

func (mmDelete *mParticipantsMockDelete) invocationsDone() bool {
	if len(mmDelete.expectations) == 0 && mmDelete.defaultExpectation == nil && mmDelete.mock.funcDelete == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDelete.mock.afterDeleteCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDelete.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Delete implements repository.Participants
func (mmDelete *ParticipantsMock) Delete(ctx context.Context, participantID int64) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmDelete.beforeDeleteCounter, 1)
	defer mm_atomic.AddUint64(&mmDelete.afterDeleteCounter, 1)

	if mmDelete.inspectFuncDelete != nil {
		mmDelete.inspectFuncDelete(ctx, participantID)
	}

	mm_params := ParticipantsMockDeleteParams{ctx, participantID}

	// Record call args
	mmDelete.DeleteMock.mutex.Lock()
	mmDelete.DeleteMock.callArgs = append(mmDelete.DeleteMock.callArgs, &mm_params)
	mmDelete.DeleteMock.mutex.Unlock()

	for _, e := range mmDelete.DeleteMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmDelete.DeleteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDelete.DeleteMock.defaultExpectation.Counter, 1)
		mm_want := mmDelete.DeleteMock.defaultExpectation.params
		mm_want_ptrs := mmDelete.DeleteMock.defaultExpectation.paramPtrs

		mm_got := ParticipantsMockDeleteParams{ctx, participantID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDelete.t.Errorf("ParticipantsMock.Delete got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.participantID != nil && !minimock.Equal(*mm_want_ptrs.participantID, mm_got.participantID) {
				mmDelete.t.Errorf("ParticipantsMock.Delete got unexpected parameter participantID, want: %#v, got: %#v%s\n", *mm_want_ptrs.participantID, mm_got.participantID, minimock.Diff(*mm_want_ptrs.participantID, mm_got.participantID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDelete.t.Errorf("ParticipantsMock.Delete got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDelete.DeleteMock.defaultExpectation.results
		if mm_results == nil {
			mmDelete.t.Fatal("No results are set for the ParticipantsMock.Delete")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmDelete.funcDelete != nil {
		return mmDelete.funcDelete(ctx, participantID)
	}
	mmDelete.t.Fatalf("Unexpected call to ParticipantsMock.Delete. %v %v", ctx, participantID)
	return
}

// DeleteAfterCounter returns a count of finished ParticipantsMock.Delete invocations
func (mmDelete *ParticipantsMock) DeleteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.afterDeleteCounter)
}

// DeleteBeforeCounter returns a count of ParticipantsMock.Delete invocations
func (mmDelete *ParticipantsMock) DeleteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.beforeDeleteCounter)
}

// Calls returns a list of arguments used in each call to ParticipantsMock.Delete.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDelete *mParticipantsMockDelete) Calls() []*ParticipantsMockDeleteParams {
	mmDelete.mutex.RLock()

	argCopy := make([]*ParticipantsMockDeleteParams, len(mmDelete.callArgs))
	copy(argCopy, mmDelete.callArgs)

	mmDelete.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteDone returns true if the count of the Delete invocations corresponds
// the number of defined expectations
func (m *ParticipantsMock) MinimockDeleteDone() bool {
	if m.DeleteMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteMock.invocationsDone()
}

// MinimockDeleteInspect logs each unmet expectation
func (m *ParticipantsMock) MinimockDeleteInspect() {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ParticipantsMock.Delete with params: %#v", *e.params)
		}
	}

	afterDeleteCounter := mm_atomic.LoadUint64(&m.afterDeleteCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && afterDeleteCounter < 1 {
		if m.DeleteMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ParticipantsMock.Delete")
		} else {
			m.t.Errorf("Expected call to ParticipantsMock.Delete with params: %#v", *m.DeleteMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && afterDeleteCounter < 1 {
		m.t.Error("Expected call to ParticipantsMock.Delete")
	}

	if !m.DeleteMock.invocationsDone() && afterDeleteCounter > 0 {
		m.t.Errorf("Expected %d calls to ParticipantsMock.Delete but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteMock.expectedInvocations), afterDeleteCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ParticipantsMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateInspect()

			m.MinimockDeleteInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ParticipantsMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ParticipantsMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateDone() &&
		m.MinimockDeleteDone()
}
