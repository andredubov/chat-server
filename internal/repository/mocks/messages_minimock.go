// Code generated by http://github.com/gojuno/minimock (v3.3.14). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/andredubov/chat-server/internal/repository.Messages -o messages_minimock.go -n MessagesMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/andredubov/chat-server/internal/service/model"
	"github.com/gojuno/minimock/v3"
)

// MessagesMock implements repository.Messages
type MessagesMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreate          func(ctx context.Context, message model.Message) (i1 int64, err error)
	inspectFuncCreate   func(ctx context.Context, message model.Message)
	afterCreateCounter  uint64
	beforeCreateCounter uint64
	CreateMock          mMessagesMockCreate

	funcDelete          func(ctx context.Context, messageID int64) (i1 int64, err error)
	inspectFuncDelete   func(ctx context.Context, messageID int64)
	afterDeleteCounter  uint64
	beforeDeleteCounter uint64
	DeleteMock          mMessagesMockDelete
}

// NewMessagesMock returns a mock for repository.Messages
func NewMessagesMock(t minimock.Tester) *MessagesMock {
	m := &MessagesMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateMock = mMessagesMockCreate{mock: m}
	m.CreateMock.callArgs = []*MessagesMockCreateParams{}

	m.DeleteMock = mMessagesMockDelete{mock: m}
	m.DeleteMock.callArgs = []*MessagesMockDeleteParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mMessagesMockCreate struct {
	optional           bool
	mock               *MessagesMock
	defaultExpectation *MessagesMockCreateExpectation
	expectations       []*MessagesMockCreateExpectation

	callArgs []*MessagesMockCreateParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// MessagesMockCreateExpectation specifies expectation struct of the Messages.Create
type MessagesMockCreateExpectation struct {
	mock      *MessagesMock
	params    *MessagesMockCreateParams
	paramPtrs *MessagesMockCreateParamPtrs
	results   *MessagesMockCreateResults
	Counter   uint64
}

// MessagesMockCreateParams contains parameters of the Messages.Create
type MessagesMockCreateParams struct {
	ctx     context.Context
	message model.Message
}

// MessagesMockCreateParamPtrs contains pointers to parameters of the Messages.Create
type MessagesMockCreateParamPtrs struct {
	ctx     *context.Context
	message *model.Message
}

// MessagesMockCreateResults contains results of the Messages.Create
type MessagesMockCreateResults struct {
	i1  int64
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreate *mMessagesMockCreate) Optional() *mMessagesMockCreate {
	mmCreate.optional = true
	return mmCreate
}

// Expect sets up expected params for Messages.Create
func (mmCreate *mMessagesMockCreate) Expect(ctx context.Context, message model.Message) *mMessagesMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("MessagesMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &MessagesMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.paramPtrs != nil {
		mmCreate.mock.t.Fatalf("MessagesMock.Create mock is already set by ExpectParams functions")
	}

	mmCreate.defaultExpectation.params = &MessagesMockCreateParams{ctx, message}
	for _, e := range mmCreate.expectations {
		if minimock.Equal(e.params, mmCreate.defaultExpectation.params) {
			mmCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreate.defaultExpectation.params)
		}
	}

	return mmCreate
}

// ExpectCtxParam1 sets up expected param ctx for Messages.Create
func (mmCreate *mMessagesMockCreate) ExpectCtxParam1(ctx context.Context) *mMessagesMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("MessagesMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &MessagesMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("MessagesMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &MessagesMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.ctx = &ctx

	return mmCreate
}

// ExpectMessageParam2 sets up expected param message for Messages.Create
func (mmCreate *mMessagesMockCreate) ExpectMessageParam2(message model.Message) *mMessagesMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("MessagesMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &MessagesMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("MessagesMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &MessagesMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.message = &message

	return mmCreate
}

// Inspect accepts an inspector function that has same arguments as the Messages.Create
func (mmCreate *mMessagesMockCreate) Inspect(f func(ctx context.Context, message model.Message)) *mMessagesMockCreate {
	if mmCreate.mock.inspectFuncCreate != nil {
		mmCreate.mock.t.Fatalf("Inspect function is already set for MessagesMock.Create")
	}

	mmCreate.mock.inspectFuncCreate = f

	return mmCreate
}

// Return sets up results that will be returned by Messages.Create
func (mmCreate *mMessagesMockCreate) Return(i1 int64, err error) *MessagesMock {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("MessagesMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &MessagesMockCreateExpectation{mock: mmCreate.mock}
	}
	mmCreate.defaultExpectation.results = &MessagesMockCreateResults{i1, err}
	return mmCreate.mock
}

// Set uses given function f to mock the Messages.Create method
func (mmCreate *mMessagesMockCreate) Set(f func(ctx context.Context, message model.Message) (i1 int64, err error)) *MessagesMock {
	if mmCreate.defaultExpectation != nil {
		mmCreate.mock.t.Fatalf("Default expectation is already set for the Messages.Create method")
	}

	if len(mmCreate.expectations) > 0 {
		mmCreate.mock.t.Fatalf("Some expectations are already set for the Messages.Create method")
	}

	mmCreate.mock.funcCreate = f
	return mmCreate.mock
}

// When sets expectation for the Messages.Create which will trigger the result defined by the following
// Then helper
func (mmCreate *mMessagesMockCreate) When(ctx context.Context, message model.Message) *MessagesMockCreateExpectation {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("MessagesMock.Create mock is already set by Set")
	}

	expectation := &MessagesMockCreateExpectation{
		mock:   mmCreate.mock,
		params: &MessagesMockCreateParams{ctx, message},
	}
	mmCreate.expectations = append(mmCreate.expectations, expectation)
	return expectation
}

// Then sets up Messages.Create return parameters for the expectation previously defined by the When method
func (e *MessagesMockCreateExpectation) Then(i1 int64, err error) *MessagesMock {
	e.results = &MessagesMockCreateResults{i1, err}
	return e.mock
}

// Times sets number of times Messages.Create should be invoked
func (mmCreate *mMessagesMockCreate) Times(n uint64) *mMessagesMockCreate {
	if n == 0 {
		mmCreate.mock.t.Fatalf("Times of MessagesMock.Create mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreate.expectedInvocations, n)
	return mmCreate
}

func (mmCreate *mMessagesMockCreate) invocationsDone() bool {
	if len(mmCreate.expectations) == 0 && mmCreate.defaultExpectation == nil && mmCreate.mock.funcCreate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreate.mock.afterCreateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Create implements repository.Messages
func (mmCreate *MessagesMock) Create(ctx context.Context, message model.Message) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmCreate.beforeCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmCreate.afterCreateCounter, 1)

	if mmCreate.inspectFuncCreate != nil {
		mmCreate.inspectFuncCreate(ctx, message)
	}

	mm_params := MessagesMockCreateParams{ctx, message}

	// Record call args
	mmCreate.CreateMock.mutex.Lock()
	mmCreate.CreateMock.callArgs = append(mmCreate.CreateMock.callArgs, &mm_params)
	mmCreate.CreateMock.mutex.Unlock()

	for _, e := range mmCreate.CreateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCreate.CreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreate.CreateMock.defaultExpectation.Counter, 1)
		mm_want := mmCreate.CreateMock.defaultExpectation.params
		mm_want_ptrs := mmCreate.CreateMock.defaultExpectation.paramPtrs

		mm_got := MessagesMockCreateParams{ctx, message}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreate.t.Errorf("MessagesMock.Create got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.message != nil && !minimock.Equal(*mm_want_ptrs.message, mm_got.message) {
				mmCreate.t.Errorf("MessagesMock.Create got unexpected parameter message, want: %#v, got: %#v%s\n", *mm_want_ptrs.message, mm_got.message, minimock.Diff(*mm_want_ptrs.message, mm_got.message))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreate.t.Errorf("MessagesMock.Create got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreate.CreateMock.defaultExpectation.results
		if mm_results == nil {
			mmCreate.t.Fatal("No results are set for the MessagesMock.Create")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCreate.funcCreate != nil {
		return mmCreate.funcCreate(ctx, message)
	}
	mmCreate.t.Fatalf("Unexpected call to MessagesMock.Create. %v %v", ctx, message)
	return
}

// CreateAfterCounter returns a count of finished MessagesMock.Create invocations
func (mmCreate *MessagesMock) CreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.afterCreateCounter)
}

// CreateBeforeCounter returns a count of MessagesMock.Create invocations
func (mmCreate *MessagesMock) CreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.beforeCreateCounter)
}

// Calls returns a list of arguments used in each call to MessagesMock.Create.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreate *mMessagesMockCreate) Calls() []*MessagesMockCreateParams {
	mmCreate.mutex.RLock()

	argCopy := make([]*MessagesMockCreateParams, len(mmCreate.callArgs))
	copy(argCopy, mmCreate.callArgs)

	mmCreate.mutex.RUnlock()

	return argCopy
}

// MinimockCreateDone returns true if the count of the Create invocations corresponds
// the number of defined expectations
func (m *MessagesMock) MinimockCreateDone() bool {
	if m.CreateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateMock.invocationsDone()
}

// MinimockCreateInspect logs each unmet expectation
func (m *MessagesMock) MinimockCreateInspect() {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MessagesMock.Create with params: %#v", *e.params)
		}
	}

	afterCreateCounter := mm_atomic.LoadUint64(&m.afterCreateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && afterCreateCounter < 1 {
		if m.CreateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MessagesMock.Create")
		} else {
			m.t.Errorf("Expected call to MessagesMock.Create with params: %#v", *m.CreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && afterCreateCounter < 1 {
		m.t.Error("Expected call to MessagesMock.Create")
	}

	if !m.CreateMock.invocationsDone() && afterCreateCounter > 0 {
		m.t.Errorf("Expected %d calls to MessagesMock.Create but found %d calls",
			mm_atomic.LoadUint64(&m.CreateMock.expectedInvocations), afterCreateCounter)
	}
}

type mMessagesMockDelete struct {
	optional           bool
	mock               *MessagesMock
	defaultExpectation *MessagesMockDeleteExpectation
	expectations       []*MessagesMockDeleteExpectation

	callArgs []*MessagesMockDeleteParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// MessagesMockDeleteExpectation specifies expectation struct of the Messages.Delete
type MessagesMockDeleteExpectation struct {
	mock      *MessagesMock
	params    *MessagesMockDeleteParams
	paramPtrs *MessagesMockDeleteParamPtrs
	results   *MessagesMockDeleteResults
	Counter   uint64
}

// MessagesMockDeleteParams contains parameters of the Messages.Delete
type MessagesMockDeleteParams struct {
	ctx       context.Context
	messageID int64
}

// MessagesMockDeleteParamPtrs contains pointers to parameters of the Messages.Delete
type MessagesMockDeleteParamPtrs struct {
	ctx       *context.Context
	messageID *int64
}

// MessagesMockDeleteResults contains results of the Messages.Delete
type MessagesMockDeleteResults struct {
	i1  int64
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDelete *mMessagesMockDelete) Optional() *mMessagesMockDelete {
	mmDelete.optional = true
	return mmDelete
}

// Expect sets up expected params for Messages.Delete
func (mmDelete *mMessagesMockDelete) Expect(ctx context.Context, messageID int64) *mMessagesMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("MessagesMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &MessagesMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.paramPtrs != nil {
		mmDelete.mock.t.Fatalf("MessagesMock.Delete mock is already set by ExpectParams functions")
	}

	mmDelete.defaultExpectation.params = &MessagesMockDeleteParams{ctx, messageID}
	for _, e := range mmDelete.expectations {
		if minimock.Equal(e.params, mmDelete.defaultExpectation.params) {
			mmDelete.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDelete.defaultExpectation.params)
		}
	}

	return mmDelete
}

// ExpectCtxParam1 sets up expected param ctx for Messages.Delete
func (mmDelete *mMessagesMockDelete) ExpectCtxParam1(ctx context.Context) *mMessagesMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("MessagesMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &MessagesMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.params != nil {
		mmDelete.mock.t.Fatalf("MessagesMock.Delete mock is already set by Expect")
	}

	if mmDelete.defaultExpectation.paramPtrs == nil {
		mmDelete.defaultExpectation.paramPtrs = &MessagesMockDeleteParamPtrs{}
	}
	mmDelete.defaultExpectation.paramPtrs.ctx = &ctx

	return mmDelete
}

// ExpectMessageIDParam2 sets up expected param messageID for Messages.Delete
func (mmDelete *mMessagesMockDelete) ExpectMessageIDParam2(messageID int64) *mMessagesMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("MessagesMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &MessagesMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.params != nil {
		mmDelete.mock.t.Fatalf("MessagesMock.Delete mock is already set by Expect")
	}

	if mmDelete.defaultExpectation.paramPtrs == nil {
		mmDelete.defaultExpectation.paramPtrs = &MessagesMockDeleteParamPtrs{}
	}
	mmDelete.defaultExpectation.paramPtrs.messageID = &messageID

	return mmDelete
}

// Inspect accepts an inspector function that has same arguments as the Messages.Delete
func (mmDelete *mMessagesMockDelete) Inspect(f func(ctx context.Context, messageID int64)) *mMessagesMockDelete {
	if mmDelete.mock.inspectFuncDelete != nil {
		mmDelete.mock.t.Fatalf("Inspect function is already set for MessagesMock.Delete")
	}

	mmDelete.mock.inspectFuncDelete = f

	return mmDelete
}

// Return sets up results that will be returned by Messages.Delete
func (mmDelete *mMessagesMockDelete) Return(i1 int64, err error) *MessagesMock {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("MessagesMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &MessagesMockDeleteExpectation{mock: mmDelete.mock}
	}
	mmDelete.defaultExpectation.results = &MessagesMockDeleteResults{i1, err}
	return mmDelete.mock
}

// Set uses given function f to mock the Messages.Delete method
func (mmDelete *mMessagesMockDelete) Set(f func(ctx context.Context, messageID int64) (i1 int64, err error)) *MessagesMock {
	if mmDelete.defaultExpectation != nil {
		mmDelete.mock.t.Fatalf("Default expectation is already set for the Messages.Delete method")
	}

	if len(mmDelete.expectations) > 0 {
		mmDelete.mock.t.Fatalf("Some expectations are already set for the Messages.Delete method")
	}

	mmDelete.mock.funcDelete = f
	return mmDelete.mock
}

// When sets expectation for the Messages.Delete which will trigger the result defined by the following
// Then helper
func (mmDelete *mMessagesMockDelete) When(ctx context.Context, messageID int64) *MessagesMockDeleteExpectation {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("MessagesMock.Delete mock is already set by Set")
	}

	expectation := &MessagesMockDeleteExpectation{
		mock:   mmDelete.mock,
		params: &MessagesMockDeleteParams{ctx, messageID},
	}
	mmDelete.expectations = append(mmDelete.expectations, expectation)
	return expectation
}

// Then sets up Messages.Delete return parameters for the expectation previously defined by the When method
func (e *MessagesMockDeleteExpectation) Then(i1 int64, err error) *MessagesMock {
	e.results = &MessagesMockDeleteResults{i1, err}
	return e.mock
}

// Times sets number of times Messages.Delete should be invoked
func (mmDelete *mMessagesMockDelete) Times(n uint64) *mMessagesMockDelete {
	if n == 0 {
		mmDelete.mock.t.Fatalf("Times of MessagesMock.Delete mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDelete.expectedInvocations, n)
	return mmDelete
}

func (mmDelete *mMessagesMockDelete) invocationsDone() bool {
	if len(mmDelete.expectations) == 0 && mmDelete.defaultExpectation == nil && mmDelete.mock.funcDelete == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDelete.mock.afterDeleteCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDelete.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Delete implements repository.Messages
func (mmDelete *MessagesMock) Delete(ctx context.Context, messageID int64) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmDelete.beforeDeleteCounter, 1)
	defer mm_atomic.AddUint64(&mmDelete.afterDeleteCounter, 1)

	if mmDelete.inspectFuncDelete != nil {
		mmDelete.inspectFuncDelete(ctx, messageID)
	}

	mm_params := MessagesMockDeleteParams{ctx, messageID}

	// Record call args
	mmDelete.DeleteMock.mutex.Lock()
	mmDelete.DeleteMock.callArgs = append(mmDelete.DeleteMock.callArgs, &mm_params)
	mmDelete.DeleteMock.mutex.Unlock()

	for _, e := range mmDelete.DeleteMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmDelete.DeleteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDelete.DeleteMock.defaultExpectation.Counter, 1)
		mm_want := mmDelete.DeleteMock.defaultExpectation.params
		mm_want_ptrs := mmDelete.DeleteMock.defaultExpectation.paramPtrs

		mm_got := MessagesMockDeleteParams{ctx, messageID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDelete.t.Errorf("MessagesMock.Delete got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.messageID != nil && !minimock.Equal(*mm_want_ptrs.messageID, mm_got.messageID) {
				mmDelete.t.Errorf("MessagesMock.Delete got unexpected parameter messageID, want: %#v, got: %#v%s\n", *mm_want_ptrs.messageID, mm_got.messageID, minimock.Diff(*mm_want_ptrs.messageID, mm_got.messageID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDelete.t.Errorf("MessagesMock.Delete got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDelete.DeleteMock.defaultExpectation.results
		if mm_results == nil {
			mmDelete.t.Fatal("No results are set for the MessagesMock.Delete")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmDelete.funcDelete != nil {
		return mmDelete.funcDelete(ctx, messageID)
	}
	mmDelete.t.Fatalf("Unexpected call to MessagesMock.Delete. %v %v", ctx, messageID)
	return
}

// DeleteAfterCounter returns a count of finished MessagesMock.Delete invocations
func (mmDelete *MessagesMock) DeleteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.afterDeleteCounter)
}

// DeleteBeforeCounter returns a count of MessagesMock.Delete invocations
func (mmDelete *MessagesMock) DeleteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.beforeDeleteCounter)
}

// Calls returns a list of arguments used in each call to MessagesMock.Delete.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDelete *mMessagesMockDelete) Calls() []*MessagesMockDeleteParams {
	mmDelete.mutex.RLock()

	argCopy := make([]*MessagesMockDeleteParams, len(mmDelete.callArgs))
	copy(argCopy, mmDelete.callArgs)

	mmDelete.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteDone returns true if the count of the Delete invocations corresponds
// the number of defined expectations
func (m *MessagesMock) MinimockDeleteDone() bool {
	if m.DeleteMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteMock.invocationsDone()
}

// MinimockDeleteInspect logs each unmet expectation
func (m *MessagesMock) MinimockDeleteInspect() {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MessagesMock.Delete with params: %#v", *e.params)
		}
	}

	afterDeleteCounter := mm_atomic.LoadUint64(&m.afterDeleteCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && afterDeleteCounter < 1 {
		if m.DeleteMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MessagesMock.Delete")
		} else {
			m.t.Errorf("Expected call to MessagesMock.Delete with params: %#v", *m.DeleteMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && afterDeleteCounter < 1 {
		m.t.Error("Expected call to MessagesMock.Delete")
	}

	if !m.DeleteMock.invocationsDone() && afterDeleteCounter > 0 {
		m.t.Errorf("Expected %d calls to MessagesMock.Delete but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteMock.expectedInvocations), afterDeleteCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *MessagesMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateInspect()

			m.MinimockDeleteInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *MessagesMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *MessagesMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateDone() &&
		m.MinimockDeleteDone()
}
