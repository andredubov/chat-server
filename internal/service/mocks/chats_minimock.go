// Code generated by http://github.com/gojuno/minimock (v3.3.14). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/andredubov/chat-server/internal/service.Chats -o chats_minimock.go -n ChatsMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/andredubov/chat-server/internal/service/model"
	"github.com/gojuno/minimock/v3"
)

// ChatsMock implements service.Chats
type ChatsMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreate          func(ctx context.Context, chat model.Chat) (i1 int64, err error)
	inspectFuncCreate   func(ctx context.Context, chat model.Chat)
	afterCreateCounter  uint64
	beforeCreateCounter uint64
	CreateMock          mChatsMockCreate

	funcDelete          func(ctx context.Context, chatID int64) (i1 int64, err error)
	inspectFuncDelete   func(ctx context.Context, chatID int64)
	afterDeleteCounter  uint64
	beforeDeleteCounter uint64
	DeleteMock          mChatsMockDelete

	funcSendMessage          func(ctx context.Context, message model.Message) (i1 int64, err error)
	inspectFuncSendMessage   func(ctx context.Context, message model.Message)
	afterSendMessageCounter  uint64
	beforeSendMessageCounter uint64
	SendMessageMock          mChatsMockSendMessage
}

// NewChatsMock returns a mock for service.Chats
func NewChatsMock(t minimock.Tester) *ChatsMock {
	m := &ChatsMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateMock = mChatsMockCreate{mock: m}
	m.CreateMock.callArgs = []*ChatsMockCreateParams{}

	m.DeleteMock = mChatsMockDelete{mock: m}
	m.DeleteMock.callArgs = []*ChatsMockDeleteParams{}

	m.SendMessageMock = mChatsMockSendMessage{mock: m}
	m.SendMessageMock.callArgs = []*ChatsMockSendMessageParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mChatsMockCreate struct {
	optional           bool
	mock               *ChatsMock
	defaultExpectation *ChatsMockCreateExpectation
	expectations       []*ChatsMockCreateExpectation

	callArgs []*ChatsMockCreateParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ChatsMockCreateExpectation specifies expectation struct of the Chats.Create
type ChatsMockCreateExpectation struct {
	mock      *ChatsMock
	params    *ChatsMockCreateParams
	paramPtrs *ChatsMockCreateParamPtrs
	results   *ChatsMockCreateResults
	Counter   uint64
}

// ChatsMockCreateParams contains parameters of the Chats.Create
type ChatsMockCreateParams struct {
	ctx  context.Context
	chat model.Chat
}

// ChatsMockCreateParamPtrs contains pointers to parameters of the Chats.Create
type ChatsMockCreateParamPtrs struct {
	ctx  *context.Context
	chat *model.Chat
}

// ChatsMockCreateResults contains results of the Chats.Create
type ChatsMockCreateResults struct {
	i1  int64
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreate *mChatsMockCreate) Optional() *mChatsMockCreate {
	mmCreate.optional = true
	return mmCreate
}

// Expect sets up expected params for Chats.Create
func (mmCreate *mChatsMockCreate) Expect(ctx context.Context, chat model.Chat) *mChatsMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("ChatsMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &ChatsMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.paramPtrs != nil {
		mmCreate.mock.t.Fatalf("ChatsMock.Create mock is already set by ExpectParams functions")
	}

	mmCreate.defaultExpectation.params = &ChatsMockCreateParams{ctx, chat}
	for _, e := range mmCreate.expectations {
		if minimock.Equal(e.params, mmCreate.defaultExpectation.params) {
			mmCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreate.defaultExpectation.params)
		}
	}

	return mmCreate
}

// ExpectCtxParam1 sets up expected param ctx for Chats.Create
func (mmCreate *mChatsMockCreate) ExpectCtxParam1(ctx context.Context) *mChatsMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("ChatsMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &ChatsMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("ChatsMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &ChatsMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.ctx = &ctx

	return mmCreate
}

// ExpectChatParam2 sets up expected param chat for Chats.Create
func (mmCreate *mChatsMockCreate) ExpectChatParam2(chat model.Chat) *mChatsMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("ChatsMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &ChatsMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("ChatsMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &ChatsMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.chat = &chat

	return mmCreate
}

// Inspect accepts an inspector function that has same arguments as the Chats.Create
func (mmCreate *mChatsMockCreate) Inspect(f func(ctx context.Context, chat model.Chat)) *mChatsMockCreate {
	if mmCreate.mock.inspectFuncCreate != nil {
		mmCreate.mock.t.Fatalf("Inspect function is already set for ChatsMock.Create")
	}

	mmCreate.mock.inspectFuncCreate = f

	return mmCreate
}

// Return sets up results that will be returned by Chats.Create
func (mmCreate *mChatsMockCreate) Return(i1 int64, err error) *ChatsMock {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("ChatsMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &ChatsMockCreateExpectation{mock: mmCreate.mock}
	}
	mmCreate.defaultExpectation.results = &ChatsMockCreateResults{i1, err}
	return mmCreate.mock
}

// Set uses given function f to mock the Chats.Create method
func (mmCreate *mChatsMockCreate) Set(f func(ctx context.Context, chat model.Chat) (i1 int64, err error)) *ChatsMock {
	if mmCreate.defaultExpectation != nil {
		mmCreate.mock.t.Fatalf("Default expectation is already set for the Chats.Create method")
	}

	if len(mmCreate.expectations) > 0 {
		mmCreate.mock.t.Fatalf("Some expectations are already set for the Chats.Create method")
	}

	mmCreate.mock.funcCreate = f
	return mmCreate.mock
}

// When sets expectation for the Chats.Create which will trigger the result defined by the following
// Then helper
func (mmCreate *mChatsMockCreate) When(ctx context.Context, chat model.Chat) *ChatsMockCreateExpectation {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("ChatsMock.Create mock is already set by Set")
	}

	expectation := &ChatsMockCreateExpectation{
		mock:   mmCreate.mock,
		params: &ChatsMockCreateParams{ctx, chat},
	}
	mmCreate.expectations = append(mmCreate.expectations, expectation)
	return expectation
}

// Then sets up Chats.Create return parameters for the expectation previously defined by the When method
func (e *ChatsMockCreateExpectation) Then(i1 int64, err error) *ChatsMock {
	e.results = &ChatsMockCreateResults{i1, err}
	return e.mock
}

// Times sets number of times Chats.Create should be invoked
func (mmCreate *mChatsMockCreate) Times(n uint64) *mChatsMockCreate {
	if n == 0 {
		mmCreate.mock.t.Fatalf("Times of ChatsMock.Create mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreate.expectedInvocations, n)
	return mmCreate
}

func (mmCreate *mChatsMockCreate) invocationsDone() bool {
	if len(mmCreate.expectations) == 0 && mmCreate.defaultExpectation == nil && mmCreate.mock.funcCreate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreate.mock.afterCreateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Create implements service.Chats
func (mmCreate *ChatsMock) Create(ctx context.Context, chat model.Chat) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmCreate.beforeCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmCreate.afterCreateCounter, 1)

	if mmCreate.inspectFuncCreate != nil {
		mmCreate.inspectFuncCreate(ctx, chat)
	}

	mm_params := ChatsMockCreateParams{ctx, chat}

	// Record call args
	mmCreate.CreateMock.mutex.Lock()
	mmCreate.CreateMock.callArgs = append(mmCreate.CreateMock.callArgs, &mm_params)
	mmCreate.CreateMock.mutex.Unlock()

	for _, e := range mmCreate.CreateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCreate.CreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreate.CreateMock.defaultExpectation.Counter, 1)
		mm_want := mmCreate.CreateMock.defaultExpectation.params
		mm_want_ptrs := mmCreate.CreateMock.defaultExpectation.paramPtrs

		mm_got := ChatsMockCreateParams{ctx, chat}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreate.t.Errorf("ChatsMock.Create got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.chat != nil && !minimock.Equal(*mm_want_ptrs.chat, mm_got.chat) {
				mmCreate.t.Errorf("ChatsMock.Create got unexpected parameter chat, want: %#v, got: %#v%s\n", *mm_want_ptrs.chat, mm_got.chat, minimock.Diff(*mm_want_ptrs.chat, mm_got.chat))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreate.t.Errorf("ChatsMock.Create got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreate.CreateMock.defaultExpectation.results
		if mm_results == nil {
			mmCreate.t.Fatal("No results are set for the ChatsMock.Create")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCreate.funcCreate != nil {
		return mmCreate.funcCreate(ctx, chat)
	}
	mmCreate.t.Fatalf("Unexpected call to ChatsMock.Create. %v %v", ctx, chat)
	return
}

// CreateAfterCounter returns a count of finished ChatsMock.Create invocations
func (mmCreate *ChatsMock) CreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.afterCreateCounter)
}

// CreateBeforeCounter returns a count of ChatsMock.Create invocations
func (mmCreate *ChatsMock) CreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.beforeCreateCounter)
}

// Calls returns a list of arguments used in each call to ChatsMock.Create.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreate *mChatsMockCreate) Calls() []*ChatsMockCreateParams {
	mmCreate.mutex.RLock()

	argCopy := make([]*ChatsMockCreateParams, len(mmCreate.callArgs))
	copy(argCopy, mmCreate.callArgs)

	mmCreate.mutex.RUnlock()

	return argCopy
}

// MinimockCreateDone returns true if the count of the Create invocations corresponds
// the number of defined expectations
func (m *ChatsMock) MinimockCreateDone() bool {
	if m.CreateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateMock.invocationsDone()
}

// MinimockCreateInspect logs each unmet expectation
func (m *ChatsMock) MinimockCreateInspect() {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatsMock.Create with params: %#v", *e.params)
		}
	}

	afterCreateCounter := mm_atomic.LoadUint64(&m.afterCreateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && afterCreateCounter < 1 {
		if m.CreateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ChatsMock.Create")
		} else {
			m.t.Errorf("Expected call to ChatsMock.Create with params: %#v", *m.CreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && afterCreateCounter < 1 {
		m.t.Error("Expected call to ChatsMock.Create")
	}

	if !m.CreateMock.invocationsDone() && afterCreateCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatsMock.Create but found %d calls",
			mm_atomic.LoadUint64(&m.CreateMock.expectedInvocations), afterCreateCounter)
	}
}

type mChatsMockDelete struct {
	optional           bool
	mock               *ChatsMock
	defaultExpectation *ChatsMockDeleteExpectation
	expectations       []*ChatsMockDeleteExpectation

	callArgs []*ChatsMockDeleteParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ChatsMockDeleteExpectation specifies expectation struct of the Chats.Delete
type ChatsMockDeleteExpectation struct {
	mock      *ChatsMock
	params    *ChatsMockDeleteParams
	paramPtrs *ChatsMockDeleteParamPtrs
	results   *ChatsMockDeleteResults
	Counter   uint64
}

// ChatsMockDeleteParams contains parameters of the Chats.Delete
type ChatsMockDeleteParams struct {
	ctx    context.Context
	chatID int64
}

// ChatsMockDeleteParamPtrs contains pointers to parameters of the Chats.Delete
type ChatsMockDeleteParamPtrs struct {
	ctx    *context.Context
	chatID *int64
}

// ChatsMockDeleteResults contains results of the Chats.Delete
type ChatsMockDeleteResults struct {
	i1  int64
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDelete *mChatsMockDelete) Optional() *mChatsMockDelete {
	mmDelete.optional = true
	return mmDelete
}

// Expect sets up expected params for Chats.Delete
func (mmDelete *mChatsMockDelete) Expect(ctx context.Context, chatID int64) *mChatsMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("ChatsMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &ChatsMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.paramPtrs != nil {
		mmDelete.mock.t.Fatalf("ChatsMock.Delete mock is already set by ExpectParams functions")
	}

	mmDelete.defaultExpectation.params = &ChatsMockDeleteParams{ctx, chatID}
	for _, e := range mmDelete.expectations {
		if minimock.Equal(e.params, mmDelete.defaultExpectation.params) {
			mmDelete.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDelete.defaultExpectation.params)
		}
	}

	return mmDelete
}

// ExpectCtxParam1 sets up expected param ctx for Chats.Delete
func (mmDelete *mChatsMockDelete) ExpectCtxParam1(ctx context.Context) *mChatsMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("ChatsMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &ChatsMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.params != nil {
		mmDelete.mock.t.Fatalf("ChatsMock.Delete mock is already set by Expect")
	}

	if mmDelete.defaultExpectation.paramPtrs == nil {
		mmDelete.defaultExpectation.paramPtrs = &ChatsMockDeleteParamPtrs{}
	}
	mmDelete.defaultExpectation.paramPtrs.ctx = &ctx

	return mmDelete
}

// ExpectChatIDParam2 sets up expected param chatID for Chats.Delete
func (mmDelete *mChatsMockDelete) ExpectChatIDParam2(chatID int64) *mChatsMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("ChatsMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &ChatsMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.params != nil {
		mmDelete.mock.t.Fatalf("ChatsMock.Delete mock is already set by Expect")
	}

	if mmDelete.defaultExpectation.paramPtrs == nil {
		mmDelete.defaultExpectation.paramPtrs = &ChatsMockDeleteParamPtrs{}
	}
	mmDelete.defaultExpectation.paramPtrs.chatID = &chatID

	return mmDelete
}

// Inspect accepts an inspector function that has same arguments as the Chats.Delete
func (mmDelete *mChatsMockDelete) Inspect(f func(ctx context.Context, chatID int64)) *mChatsMockDelete {
	if mmDelete.mock.inspectFuncDelete != nil {
		mmDelete.mock.t.Fatalf("Inspect function is already set for ChatsMock.Delete")
	}

	mmDelete.mock.inspectFuncDelete = f

	return mmDelete
}

// Return sets up results that will be returned by Chats.Delete
func (mmDelete *mChatsMockDelete) Return(i1 int64, err error) *ChatsMock {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("ChatsMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &ChatsMockDeleteExpectation{mock: mmDelete.mock}
	}
	mmDelete.defaultExpectation.results = &ChatsMockDeleteResults{i1, err}
	return mmDelete.mock
}

// Set uses given function f to mock the Chats.Delete method
func (mmDelete *mChatsMockDelete) Set(f func(ctx context.Context, chatID int64) (i1 int64, err error)) *ChatsMock {
	if mmDelete.defaultExpectation != nil {
		mmDelete.mock.t.Fatalf("Default expectation is already set for the Chats.Delete method")
	}

	if len(mmDelete.expectations) > 0 {
		mmDelete.mock.t.Fatalf("Some expectations are already set for the Chats.Delete method")
	}

	mmDelete.mock.funcDelete = f
	return mmDelete.mock
}

// When sets expectation for the Chats.Delete which will trigger the result defined by the following
// Then helper
func (mmDelete *mChatsMockDelete) When(ctx context.Context, chatID int64) *ChatsMockDeleteExpectation {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("ChatsMock.Delete mock is already set by Set")
	}

	expectation := &ChatsMockDeleteExpectation{
		mock:   mmDelete.mock,
		params: &ChatsMockDeleteParams{ctx, chatID},
	}
	mmDelete.expectations = append(mmDelete.expectations, expectation)
	return expectation
}

// Then sets up Chats.Delete return parameters for the expectation previously defined by the When method
func (e *ChatsMockDeleteExpectation) Then(i1 int64, err error) *ChatsMock {
	e.results = &ChatsMockDeleteResults{i1, err}
	return e.mock
}

// Times sets number of times Chats.Delete should be invoked
func (mmDelete *mChatsMockDelete) Times(n uint64) *mChatsMockDelete {
	if n == 0 {
		mmDelete.mock.t.Fatalf("Times of ChatsMock.Delete mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDelete.expectedInvocations, n)
	return mmDelete
}

func (mmDelete *mChatsMockDelete) invocationsDone() bool {
	if len(mmDelete.expectations) == 0 && mmDelete.defaultExpectation == nil && mmDelete.mock.funcDelete == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDelete.mock.afterDeleteCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDelete.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Delete implements service.Chats
func (mmDelete *ChatsMock) Delete(ctx context.Context, chatID int64) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmDelete.beforeDeleteCounter, 1)
	defer mm_atomic.AddUint64(&mmDelete.afterDeleteCounter, 1)

	if mmDelete.inspectFuncDelete != nil {
		mmDelete.inspectFuncDelete(ctx, chatID)
	}

	mm_params := ChatsMockDeleteParams{ctx, chatID}

	// Record call args
	mmDelete.DeleteMock.mutex.Lock()
	mmDelete.DeleteMock.callArgs = append(mmDelete.DeleteMock.callArgs, &mm_params)
	mmDelete.DeleteMock.mutex.Unlock()

	for _, e := range mmDelete.DeleteMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmDelete.DeleteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDelete.DeleteMock.defaultExpectation.Counter, 1)
		mm_want := mmDelete.DeleteMock.defaultExpectation.params
		mm_want_ptrs := mmDelete.DeleteMock.defaultExpectation.paramPtrs

		mm_got := ChatsMockDeleteParams{ctx, chatID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDelete.t.Errorf("ChatsMock.Delete got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.chatID != nil && !minimock.Equal(*mm_want_ptrs.chatID, mm_got.chatID) {
				mmDelete.t.Errorf("ChatsMock.Delete got unexpected parameter chatID, want: %#v, got: %#v%s\n", *mm_want_ptrs.chatID, mm_got.chatID, minimock.Diff(*mm_want_ptrs.chatID, mm_got.chatID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDelete.t.Errorf("ChatsMock.Delete got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDelete.DeleteMock.defaultExpectation.results
		if mm_results == nil {
			mmDelete.t.Fatal("No results are set for the ChatsMock.Delete")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmDelete.funcDelete != nil {
		return mmDelete.funcDelete(ctx, chatID)
	}
	mmDelete.t.Fatalf("Unexpected call to ChatsMock.Delete. %v %v", ctx, chatID)
	return
}

// DeleteAfterCounter returns a count of finished ChatsMock.Delete invocations
func (mmDelete *ChatsMock) DeleteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.afterDeleteCounter)
}

// DeleteBeforeCounter returns a count of ChatsMock.Delete invocations
func (mmDelete *ChatsMock) DeleteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.beforeDeleteCounter)
}

// Calls returns a list of arguments used in each call to ChatsMock.Delete.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDelete *mChatsMockDelete) Calls() []*ChatsMockDeleteParams {
	mmDelete.mutex.RLock()

	argCopy := make([]*ChatsMockDeleteParams, len(mmDelete.callArgs))
	copy(argCopy, mmDelete.callArgs)

	mmDelete.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteDone returns true if the count of the Delete invocations corresponds
// the number of defined expectations
func (m *ChatsMock) MinimockDeleteDone() bool {
	if m.DeleteMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteMock.invocationsDone()
}

// MinimockDeleteInspect logs each unmet expectation
func (m *ChatsMock) MinimockDeleteInspect() {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatsMock.Delete with params: %#v", *e.params)
		}
	}

	afterDeleteCounter := mm_atomic.LoadUint64(&m.afterDeleteCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && afterDeleteCounter < 1 {
		if m.DeleteMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ChatsMock.Delete")
		} else {
			m.t.Errorf("Expected call to ChatsMock.Delete with params: %#v", *m.DeleteMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && afterDeleteCounter < 1 {
		m.t.Error("Expected call to ChatsMock.Delete")
	}

	if !m.DeleteMock.invocationsDone() && afterDeleteCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatsMock.Delete but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteMock.expectedInvocations), afterDeleteCounter)
	}
}

type mChatsMockSendMessage struct {
	optional           bool
	mock               *ChatsMock
	defaultExpectation *ChatsMockSendMessageExpectation
	expectations       []*ChatsMockSendMessageExpectation

	callArgs []*ChatsMockSendMessageParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// ChatsMockSendMessageExpectation specifies expectation struct of the Chats.SendMessage
type ChatsMockSendMessageExpectation struct {
	mock      *ChatsMock
	params    *ChatsMockSendMessageParams
	paramPtrs *ChatsMockSendMessageParamPtrs
	results   *ChatsMockSendMessageResults
	Counter   uint64
}

// ChatsMockSendMessageParams contains parameters of the Chats.SendMessage
type ChatsMockSendMessageParams struct {
	ctx     context.Context
	message model.Message
}

// ChatsMockSendMessageParamPtrs contains pointers to parameters of the Chats.SendMessage
type ChatsMockSendMessageParamPtrs struct {
	ctx     *context.Context
	message *model.Message
}

// ChatsMockSendMessageResults contains results of the Chats.SendMessage
type ChatsMockSendMessageResults struct {
	i1  int64
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSendMessage *mChatsMockSendMessage) Optional() *mChatsMockSendMessage {
	mmSendMessage.optional = true
	return mmSendMessage
}

// Expect sets up expected params for Chats.SendMessage
func (mmSendMessage *mChatsMockSendMessage) Expect(ctx context.Context, message model.Message) *mChatsMockSendMessage {
	if mmSendMessage.mock.funcSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("ChatsMock.SendMessage mock is already set by Set")
	}

	if mmSendMessage.defaultExpectation == nil {
		mmSendMessage.defaultExpectation = &ChatsMockSendMessageExpectation{}
	}

	if mmSendMessage.defaultExpectation.paramPtrs != nil {
		mmSendMessage.mock.t.Fatalf("ChatsMock.SendMessage mock is already set by ExpectParams functions")
	}

	mmSendMessage.defaultExpectation.params = &ChatsMockSendMessageParams{ctx, message}
	for _, e := range mmSendMessage.expectations {
		if minimock.Equal(e.params, mmSendMessage.defaultExpectation.params) {
			mmSendMessage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSendMessage.defaultExpectation.params)
		}
	}

	return mmSendMessage
}

// ExpectCtxParam1 sets up expected param ctx for Chats.SendMessage
func (mmSendMessage *mChatsMockSendMessage) ExpectCtxParam1(ctx context.Context) *mChatsMockSendMessage {
	if mmSendMessage.mock.funcSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("ChatsMock.SendMessage mock is already set by Set")
	}

	if mmSendMessage.defaultExpectation == nil {
		mmSendMessage.defaultExpectation = &ChatsMockSendMessageExpectation{}
	}

	if mmSendMessage.defaultExpectation.params != nil {
		mmSendMessage.mock.t.Fatalf("ChatsMock.SendMessage mock is already set by Expect")
	}

	if mmSendMessage.defaultExpectation.paramPtrs == nil {
		mmSendMessage.defaultExpectation.paramPtrs = &ChatsMockSendMessageParamPtrs{}
	}
	mmSendMessage.defaultExpectation.paramPtrs.ctx = &ctx

	return mmSendMessage
}

// ExpectMessageParam2 sets up expected param message for Chats.SendMessage
func (mmSendMessage *mChatsMockSendMessage) ExpectMessageParam2(message model.Message) *mChatsMockSendMessage {
	if mmSendMessage.mock.funcSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("ChatsMock.SendMessage mock is already set by Set")
	}

	if mmSendMessage.defaultExpectation == nil {
		mmSendMessage.defaultExpectation = &ChatsMockSendMessageExpectation{}
	}

	if mmSendMessage.defaultExpectation.params != nil {
		mmSendMessage.mock.t.Fatalf("ChatsMock.SendMessage mock is already set by Expect")
	}

	if mmSendMessage.defaultExpectation.paramPtrs == nil {
		mmSendMessage.defaultExpectation.paramPtrs = &ChatsMockSendMessageParamPtrs{}
	}
	mmSendMessage.defaultExpectation.paramPtrs.message = &message

	return mmSendMessage
}

// Inspect accepts an inspector function that has same arguments as the Chats.SendMessage
func (mmSendMessage *mChatsMockSendMessage) Inspect(f func(ctx context.Context, message model.Message)) *mChatsMockSendMessage {
	if mmSendMessage.mock.inspectFuncSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("Inspect function is already set for ChatsMock.SendMessage")
	}

	mmSendMessage.mock.inspectFuncSendMessage = f

	return mmSendMessage
}

// Return sets up results that will be returned by Chats.SendMessage
func (mmSendMessage *mChatsMockSendMessage) Return(i1 int64, err error) *ChatsMock {
	if mmSendMessage.mock.funcSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("ChatsMock.SendMessage mock is already set by Set")
	}

	if mmSendMessage.defaultExpectation == nil {
		mmSendMessage.defaultExpectation = &ChatsMockSendMessageExpectation{mock: mmSendMessage.mock}
	}
	mmSendMessage.defaultExpectation.results = &ChatsMockSendMessageResults{i1, err}
	return mmSendMessage.mock
}

// Set uses given function f to mock the Chats.SendMessage method
func (mmSendMessage *mChatsMockSendMessage) Set(f func(ctx context.Context, message model.Message) (i1 int64, err error)) *ChatsMock {
	if mmSendMessage.defaultExpectation != nil {
		mmSendMessage.mock.t.Fatalf("Default expectation is already set for the Chats.SendMessage method")
	}

	if len(mmSendMessage.expectations) > 0 {
		mmSendMessage.mock.t.Fatalf("Some expectations are already set for the Chats.SendMessage method")
	}

	mmSendMessage.mock.funcSendMessage = f
	return mmSendMessage.mock
}

// When sets expectation for the Chats.SendMessage which will trigger the result defined by the following
// Then helper
func (mmSendMessage *mChatsMockSendMessage) When(ctx context.Context, message model.Message) *ChatsMockSendMessageExpectation {
	if mmSendMessage.mock.funcSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("ChatsMock.SendMessage mock is already set by Set")
	}

	expectation := &ChatsMockSendMessageExpectation{
		mock:   mmSendMessage.mock,
		params: &ChatsMockSendMessageParams{ctx, message},
	}
	mmSendMessage.expectations = append(mmSendMessage.expectations, expectation)
	return expectation
}

// Then sets up Chats.SendMessage return parameters for the expectation previously defined by the When method
func (e *ChatsMockSendMessageExpectation) Then(i1 int64, err error) *ChatsMock {
	e.results = &ChatsMockSendMessageResults{i1, err}
	return e.mock
}

// Times sets number of times Chats.SendMessage should be invoked
func (mmSendMessage *mChatsMockSendMessage) Times(n uint64) *mChatsMockSendMessage {
	if n == 0 {
		mmSendMessage.mock.t.Fatalf("Times of ChatsMock.SendMessage mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSendMessage.expectedInvocations, n)
	return mmSendMessage
}

func (mmSendMessage *mChatsMockSendMessage) invocationsDone() bool {
	if len(mmSendMessage.expectations) == 0 && mmSendMessage.defaultExpectation == nil && mmSendMessage.mock.funcSendMessage == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSendMessage.mock.afterSendMessageCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSendMessage.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SendMessage implements service.Chats
func (mmSendMessage *ChatsMock) SendMessage(ctx context.Context, message model.Message) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmSendMessage.beforeSendMessageCounter, 1)
	defer mm_atomic.AddUint64(&mmSendMessage.afterSendMessageCounter, 1)

	if mmSendMessage.inspectFuncSendMessage != nil {
		mmSendMessage.inspectFuncSendMessage(ctx, message)
	}

	mm_params := ChatsMockSendMessageParams{ctx, message}

	// Record call args
	mmSendMessage.SendMessageMock.mutex.Lock()
	mmSendMessage.SendMessageMock.callArgs = append(mmSendMessage.SendMessageMock.callArgs, &mm_params)
	mmSendMessage.SendMessageMock.mutex.Unlock()

	for _, e := range mmSendMessage.SendMessageMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmSendMessage.SendMessageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSendMessage.SendMessageMock.defaultExpectation.Counter, 1)
		mm_want := mmSendMessage.SendMessageMock.defaultExpectation.params
		mm_want_ptrs := mmSendMessage.SendMessageMock.defaultExpectation.paramPtrs

		mm_got := ChatsMockSendMessageParams{ctx, message}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSendMessage.t.Errorf("ChatsMock.SendMessage got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.message != nil && !minimock.Equal(*mm_want_ptrs.message, mm_got.message) {
				mmSendMessage.t.Errorf("ChatsMock.SendMessage got unexpected parameter message, want: %#v, got: %#v%s\n", *mm_want_ptrs.message, mm_got.message, minimock.Diff(*mm_want_ptrs.message, mm_got.message))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSendMessage.t.Errorf("ChatsMock.SendMessage got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSendMessage.SendMessageMock.defaultExpectation.results
		if mm_results == nil {
			mmSendMessage.t.Fatal("No results are set for the ChatsMock.SendMessage")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmSendMessage.funcSendMessage != nil {
		return mmSendMessage.funcSendMessage(ctx, message)
	}
	mmSendMessage.t.Fatalf("Unexpected call to ChatsMock.SendMessage. %v %v", ctx, message)
	return
}

// SendMessageAfterCounter returns a count of finished ChatsMock.SendMessage invocations
func (mmSendMessage *ChatsMock) SendMessageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendMessage.afterSendMessageCounter)
}

// SendMessageBeforeCounter returns a count of ChatsMock.SendMessage invocations
func (mmSendMessage *ChatsMock) SendMessageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendMessage.beforeSendMessageCounter)
}

// Calls returns a list of arguments used in each call to ChatsMock.SendMessage.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSendMessage *mChatsMockSendMessage) Calls() []*ChatsMockSendMessageParams {
	mmSendMessage.mutex.RLock()

	argCopy := make([]*ChatsMockSendMessageParams, len(mmSendMessage.callArgs))
	copy(argCopy, mmSendMessage.callArgs)

	mmSendMessage.mutex.RUnlock()

	return argCopy
}

// MinimockSendMessageDone returns true if the count of the SendMessage invocations corresponds
// the number of defined expectations
func (m *ChatsMock) MinimockSendMessageDone() bool {
	if m.SendMessageMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SendMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SendMessageMock.invocationsDone()
}

// MinimockSendMessageInspect logs each unmet expectation
func (m *ChatsMock) MinimockSendMessageInspect() {
	for _, e := range m.SendMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatsMock.SendMessage with params: %#v", *e.params)
		}
	}

	afterSendMessageCounter := mm_atomic.LoadUint64(&m.afterSendMessageCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SendMessageMock.defaultExpectation != nil && afterSendMessageCounter < 1 {
		if m.SendMessageMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ChatsMock.SendMessage")
		} else {
			m.t.Errorf("Expected call to ChatsMock.SendMessage with params: %#v", *m.SendMessageMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSendMessage != nil && afterSendMessageCounter < 1 {
		m.t.Error("Expected call to ChatsMock.SendMessage")
	}

	if !m.SendMessageMock.invocationsDone() && afterSendMessageCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatsMock.SendMessage but found %d calls",
			mm_atomic.LoadUint64(&m.SendMessageMock.expectedInvocations), afterSendMessageCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ChatsMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateInspect()

			m.MinimockDeleteInspect()

			m.MinimockSendMessageInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ChatsMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ChatsMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateDone() &&
		m.MinimockDeleteDone() &&
		m.MinimockSendMessageDone()
}
